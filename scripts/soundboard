#!/bin/sh

SOUNDBOARD_SINK="soundboard"

################################################################################

MIX_SINK="$SOUNDBOARD_SINK""_mix"
STATE_FILE="/tmp/soundboard_mic"

check_system_compatibility() {
    # Check if pactl is available
    if ! command -v pactl >/dev/null 2>&1; then
        echo "Error: pactl not found. Please install PulseAudio or PipeWire with pactl support."
        exit 1
    fi

    # Check if pulseaudio or pipewire-pulse is running
    if ! pactl info >/dev/null 2>&1; then
        echo "Error: Unable to connect to PulseAudio or PipeWire. Make sure one of them is running."
        exit 1
    fi
}

start_mixer() {
    # Resolve defaults
    DEFAULT_SINK=$(pactl get-default-sink)
    DEFAULT_MIC_SRC=$(pactl get-default-source)

    # Create the sinks
    SOUNDBOARD_SINK_ID=$(pactl load-module module-null-sink sink_name="$SOUNDBOARD_SINK" sink_properties=device.description="Soundboard File Input")
    MIX_SINK_ID=$(pactl load-module module-null-sink sink_name="$MIX_SINK" sink_properties=device.description="Soundboard Mic")

    # Pick a physical mic (first non-monitor if default is unavailable)
    MIC_SOURCE=$DEFAULT_MIC_SRC
    if [ -z "$MIC_SOURCE" ] || echo "$MIC_SOURCE" | grep -q "monitor"; then
        MIC_SOURCE=$(pactl list short sources | awk '!/monitor/ {print $2; exit}')
    fi

    # Loopbacks:
    # 1) mic -> MIX_SINK (so voice goes into the virtual mic
    LB_MIC_TO_MIX=$(pactl load-module module-loopback source="$MIC_SOURCE" sink="$MIX_SINK" latency_msec=50)

    # 2) soundboard input -> MIX_SINK (so audio from files goes into the virtual mic)
    LB_SOUNDBOARD_TO_MIX=$(pactl load-module module-loopback source="$SOUNDBOARD_SINK.monitor" sink="$MIX_SINK" latency_msec=50)

    # 3) soundboard input -> default output (so the audio can be heard in the system)
    LB_SOUNDBOARD_TO_SYS=$(pactl load-module module-loopback source="$SOUNDBOARD_SINK.monitor" sink="$DEFAULT_SINK" latency_msec=50)

    # Reduce the volume of the soundboard-to-system loopback so it's quieter for
    # us, while others still hear it at full volume
    SINK_INPUT_ID=$(pactl list sink-inputs \
        | grep -i -B 2 "owner module: $LB_SOUNDBOARD_TO_SYS" \
        | head -1 \
        | sed 's/^Sink Input #//')
    pactl set-sink-input-volume "$SINK_INPUT_ID" "80%"

    # Save the state (with the previous default microphone) to restore later
    echo "# DO NOT EDIT. Automatically generated." > "$STATE_FILE"
    echo "SOUNDBOARD_SINK_ID='$SOUNDBOARD_SINK_ID'" >> "$STATE_FILE"
    echo "MIX_SINK_ID='$MIX_SINK_ID'" >> "$STATE_FILE"
    echo "LB_MIC_TO_MIX='$LB_MIC_TO_MIX'" >> "$STATE_FILE"
    echo "LB_SOUNDBOARD_TO_MIX='$LB_SOUNDBOARD_TO_MIX'" >> "$STATE_FILE"
    echo "LB_SOUNDBOARD_TO_SYS='$LB_SOUNDBOARD_TO_SYS'" >> "$STATE_FILE"
    echo "DEFAULT_MIC_SRC='$DEFAULT_MIC_SRC'" >> "$STATE_FILE"

    # Set the mixed monitor as the system default microphone
    pactl set-default-source "$MIX_SINK.monitor"

    echo "Full state at: $STATE_FILE"
    echo "System default mic is now: $MIX_SINK.monitor"
    echo "Send MPV to: pulse/$SOUNDBOARD_SINK"
    echo "For example: mpv --audio-device=\"pulse/$SOUNDBOARD_SINK\" <file>"
}

stop_mixer() {
    # Make sure we have state to restore
    if [ ! -f "$STATE_FILE" ]; then
        echo "No state file; nothing to stop."
        exit 1
    fi

    # Read the IDs back
    . "$STATE_FILE"

    # Unload in reverse-ish order
    pactl unload-module "$LB_SOUNDBOARD_TO_SYS"
    pactl unload-module "$LB_SOUNDBOARD_TO_MIX"
    pactl unload-module "$LB_MIC_TO_MIX"
    pactl unload-module "$MIX_SINK_ID"
    pactl unload-module "$SOUNDBOARD_SINK_ID"

    # Restore default mic if we had one
    if [ -n "$DEFAULT_MIC_SRC" ]; then
        pactl set-default-source "$DEFAULT_MIC_SRC"
        echo "Restored default mic: $DEFAULT_MIC_SRC"
    fi

    rm -f "$STATE_FILE"
}

check_system_compatibility

if [ -f "$STATE_FILE" ]; then
    stop_mixer
else
    start_mixer
fi
